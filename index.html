const { Plugin, Modal, Setting, Notice, WorkspaceLeaf, TFile } = require('obsidian');

// AI-Powered Obsidian Plugin - Complete Implementation
class AILinksPlugin extends Plugin {
    async onload() {
        console.log('AI Links Plugin - Superintelligence System Loading...');

        // Initialize all systems
        this.aiCore = new AICore(this);
        this.memorySystem = new MemorySystem(this);
        this.contextEngine = new ContextEngine(this);
        this.financialIntelligence = new FinancialIntelligence(this);

        await this.initializeSystems();
        this.addCommands();
        this.addRibbonIcon('brain-circuit', 'AI Superintelligence Hub', () => this.openAIHub());
        
        console.log('ðŸ§  AI Superintelligence System: ONLINE');
        new Notice('ðŸš€ AI Superintelligence System: Fully Operational!');
    }

    async initializeSystems() {
        await this.aiCore.initialize();
        await this.memorySystem.initialize();
        await this.contextEngine.initialize();
        await this.financialIntelligence.initialize();
    }

    addCommands() {
        // Core AI Commands
        this.addCommand({
            id: 'open-ai-hub',
            name: 'ðŸ§  Open AI Superintelligence Hub',
            callback: () => this.openAIHub()
        });

        this.addCommand({
            id: 'quick-ai-analysis',
            name: 'âš¡ Quick AI Analysis',
            callback: () => this.quickAIAnalysis()
        });

        this.addCommand({
            id: 'ai-financial-dashboard',
            name: 'ðŸ’° AI Financial Dashboard', 
            callback: () => this.openFinancialDashboard()
        });

        this.addCommand({
            id: 'ai-document-intelligence',
            name: 'ðŸ“„ AI Document Intelligence',
            callback: () => this.openDocumentIntelligence()
        });

        this.addCommand({
            id: 'ai-multi-launcher',
            name: 'ðŸš€ AI Multi-Feature Launcher',
            callback: () => this.openMultiLauncher()
        });
    }

    async openAIHub() {
        new AIHubModal(this).open();
    }

    async quickAIAnalysis() {
        new QuickAnalysisModal(this).open();
    }

    async openFinancialDashboard() {
        new FinancialDashboardModal(this).open();
    }

    async openDocumentIntelligence() {
        new DocumentIntelligenceModal(this).open();
    }

    async openMultiLauncher() {
        new MultiLauncherModal(this).open();
    }

    onunload() {
        console.log('AI Links Plugin unloaded');
    }
}

// AI Core Intelligence Engine
class AICore {
    constructor(plugin) {
        this.plugin = plugin;
        this.intelligence = new Map();
        this.analysisHistory = [];
    }

    async initialize() {
        console.log('AI Core Intelligence Engine: Initializing...');
        await this.loadIntelligenceProfiles();
        console.log('AI Core: Online');
    }

    async loadIntelligenceProfiles() {
        this.intelligence.set('analysis', {
            strength: 'Pattern Recognition',
            capability: 'Advanced Content Analysis',
            status: 'Active'
        });
        
        this.intelligence.set('prediction', {
            strength: 'Predictive Modeling',
            capability: 'Future Trend Analysis',
            status: 'Active'
        });
    }

    async analyzeContent(content) {
        const analysis = {
            timestamp: Date.now(),
            wordCount: content.split(' ').length,
            sentiment: this.analyzeSentiment(content),
            complexity: this.analyzeComplexity(content),
            topics: this.extractTopics(content),
            readability: this.calculateReadability(content)
        };

        this.analysisHistory.push(analysis);
        return analysis;
    }

    analyzeSentiment(content) {
        const positiveWords = ['good', 'great', 'excellent', 'amazing', 'wonderful', 'positive', 'success', 'achievement'];
        const negativeWords = ['bad', 'terrible', 'awful', 'negative', 'problem', 'issue', 'failure', 'disappointing'];
        
        const words = content.toLowerCase().split(/\s+/);
        let positiveCount = 0;
        let negativeCount = 0;

        words.forEach(word => {
            if (positiveWords.includes(word)) positiveCount++;
            if (negativeWords.includes(word)) negativeCount++;
        });

        if (positiveCount > negativeCount) return 'Positive';
        if (negativeCount > positiveCount) return 'Negative';
        return 'Neutral';
    }

    analyzeComplexity(content) {
        const sentences = content.split(/[.!?]+/).length;
        const words = content.split(/\s+/).length;
        const avgWordsPerSentence = words / sentences;

        if (avgWordsPerSentence > 20) return 'Complex';
        if (avgWordsPerSentence > 15) return 'Moderate';
        return 'Simple';
    }

    extractTopics(content) {
        const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should'];
        const words = content.toLowerCase().match(/\b\w+\b/g) || [];
        const wordFreq = {};

        words.forEach(word => {
            if (word.length > 3 && !stopWords.includes(word)) {
                wordFreq[word] = (wordFreq[word] || 0) + 1;
            }
        });

        return Object.entries(wordFreq)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(entry => entry[0]);
    }

    calculateReadability(content) {
        const sentences = content.split(/[.!?]+/).length;
        const words = content.split(/\s+/).length;
        const syllables = this.countSyllables(content);

        // Flesch Reading Ease Score
        const score = 206.835 - (1.015 * (words / sentences)) - (84.6 * (syllables / words));
        
        if (score >= 90) return 'Very Easy';
        if (score >= 80) return 'Easy';
        if (score >= 70) return 'Fairly Easy';
        if (score >= 60) return 'Standard';
        if (score >= 50) return 'Fairly Difficult';
        if (score >= 30) return 'Difficult';
        return 'Very Difficult';
    }

    countSyllables(content) {
        const words = content.toLowerCase().match(/\b\w+\b/g) || [];
        let totalSyllables = 0;

        words.forEach(word => {
            let syllables = word.match(/[aeiouy]+/g);
            if (syllables) {
                totalSyllables += syllables.length;
            } else {
                totalSyllables += 1;
            }
        });

        return totalSyllables;
    }
}

// Memory System for AI Learning
class MemorySystem {
    constructor(plugin) {
        this.plugin = plugin;
        this.memories = [];
        this.patterns = new Map();
    }

    async initialize() {
        await this.loadMemories();
        console.log('Memory System initialized');
    }

    async loadMemories() {
        // Load from localStorage or file
        const savedMemories = localStorage.getItem('ai-memories');
        if (savedMemories) {
            this.memories = JSON.parse(savedMemories);
        }
    }

    async saveMemories() {
        localStorage.setItem('ai-memories', JSON.stringify(this.memories));
    }

    recordInteraction(type, data) {
        const memory = {
            id: Date.now(),
            timestamp: new Date().toISOString(),
            type: type,
            data: data,
            context: this.plugin.contextEngine.getCurrentContext()
        };

        this.memories.push(memory);
        this.analyzePatterns();
        this.saveMemories();

        return memory;
    }

    analyzePatterns() {
        const recentMemories = this.memories.slice(-50);
        const typeFrequency = {};

        recentMemories.forEach(memory => {
            typeFrequency[memory.type] = (typeFrequency[memory.type] || 0) + 1;
        });

        this.patterns.set('usage_patterns', typeFrequency);
        this.patterns.set('peak_hours', this.analyzePeakUsage(recentMemories));
    }

    analyzePeakUsage(memories) {
        const hourlyUsage = {};
        
        memories.forEach(memory => {
            const hour = new Date(memory.timestamp).getHours();
            hourlyUsage[hour] = (hourlyUsage[hour] || 0) + 1;
        });

        const peakHour = Object.entries(hourlyUsage).reduce((a, b) => 
            hourlyUsage[a] > hourlyUsage[b] ? a : b, 0);

        return `Peak usage at ${peakHour}:00`;
    }

    getInsights() {
        return {
            totalMemories: this.memories.length,
            patterns: Object.fromEntries(this.patterns),
            recentActivity: this.memories.slice(-10),
            trends: this.analyzeTrends(this.memories)
        };
    }

    analyzeTrends(memories) {
        if (memories.length < 10) return 'Insufficient data for trend analysis';
        
        const recent = memories.filter(m => Date.now() - new Date(m.timestamp).getTime() < (3 * 24 * 60 * 60 * 1000));
        const older = memories.filter(m => {
            const age = Date.now() - new Date(m.timestamp).getTime();
            return age >= (3 * 24 * 60 * 60 * 1000) && age < (7 * 24 * 60 * 60 * 1000);
        });
        
        if (recent.length > older.length * 1.5) {
            return 'Increasing AI usage activity';
        } else if (recent.length < older.length * 0.5) {
            return 'Decreasing AI usage activity';
        }
        return 'Stable AI usage patterns';
    }
}

// Context Engine - COMPLETED
class ContextEngine {
    constructor(plugin) {
        this.plugin = plugin;
        this.currentContext = {};
        this.contextHistory = [];
    }

    async initialize() {
        await this.updateContext();
        console.log('Context Engine initialized');
    }

    async getCurrentContext() {
        const context = await this.gatherContextualInformation();
        return this.formatContext(context);
    }

    async gatherContextualInformation() {
        const context = {
            currentFile: this.getCurrentFileContext(),
            recentFiles: await this.getRecentFilesContext(),
            timeContext: this.getTimeContext(),
            vaultStats: this.getVaultContext(),
            workspaceState: this.getWorkspaceState()
        };

        return context;
    }

    getCurrentFileContext() {
        const activeLeaf = this.plugin.app.workspace.activeLeaf;
        if (!activeLeaf || !activeLeaf.view.file) return null;

        const file = activeLeaf.view.file;
        return {
            name: file.basename,
            path: file.path,
            size: file.stat.size,
            created: new Date(file.stat.ctime).toISOString(),
            modified: new Date(file.stat.mtime).toISOString(),
            extension: file.extension
        };
    }

    async getRecentFilesContext() {
        const files = this.plugin.app.vault.getMarkdownFiles();
        const recent = files
            .sort((a, b) => b.stat.mtime - a.stat.mtime)
            .slice(0, 5)
            .map(f => ({ 
                name: f.basename, 
                modified: new Date(f.stat.mtime).toISOString(),
                size: f.stat.size 
            }));
        
        return recent;
    }

    getTimeContext() {
        const now = new Date();
        return {
            date: now.toDateString(),
            time: now.toTimeString().split(' ')[0],
            dayOfWeek: now.toLocaleDateString('en-US', { weekday: 'long' }),
            hour: now.getHours(),
            isWeekend: now.getDay() === 0 || now.getDay() === 6,
            timeOfDay: this.getTimeOfDay(now.getHours())
        };
    }

    getTimeOfDay(hour) {
        if (hour < 6) return 'Early Morning';
        if (hour < 12) return 'Morning';
        if (hour < 17) return 'Afternoon';
        if (hour < 21) return 'Evening';
        return 'Night';
    }

    getVaultContext() {
        const files = this.plugin.app.vault.getAllLoadedFiles();
        const markdownFiles = files.filter(f => f.extension === 'md');
        
        return {
            totalFiles: files.length,
            markdownFiles: markdownFiles.length,
            totalSize: files.reduce((sum, f) => sum + (f.stat?.size || 0), 0),
            vaultName: this.plugin.app.vault.adapter.getName?.() || 'Unknown'
        };
    }

    getWorkspaceState() {
        const workspace = this.plugin.app.workspace;
        return {
            activeViewType: workspace.activeLeaf?.view?.getViewType?.() || 'unknown',
            openTabs: workspace.getLeavesOfType('markdown').length,
            sidebarOpen: workspace.leftSplit.collapsed === false,
            layoutReady: workspace.layoutReady
        };
    }

    formatContext(context) {
        return {
            summary: this.generateContextSummary(context),
            details: context,
            timestamp: new Date().toISOString()
        };
    }

    generateContextSummary(context) {
        const parts = [];
        
        if (context.currentFile) {
            parts.push(`Working on: ${context.currentFile.name}`);
        }
        
        parts.push(`Time: ${context.timeContext.timeOfDay} on ${context.timeContext.dayOfWeek}`);
        parts.push(`Vault: ${context.vaultStats.markdownFiles} notes, ${context.workspaceState.openTabs} tabs open`);
        
        return parts.join(' | ');
    }

    async updateContext() {
        this.currentContext = await this.getCurrentContext();
        this.contextHistory.push(this.currentContext);
        
        // Keep only recent context history
        if (this.contextHistory.length > 50) {
            this.contextHistory = this.contextHistory.slice(-50);
        }
    }
}

// Financial Intelligence System - COMPLETED
class FinancialIntelligence {
    constructor(plugin) {
        this.plugin = plugin;
        this.portfolioData = new Map();
        this.marketData = new Map();
        this.budgetTracker = new Map();
        this.initialized = false;
    }

    async initialize() {
        await this.loadFinancialData();
        this.initialized = true;
        console.log('Financial Intelligence System: Online');
    }

    async loadFinancialData() {
        const savedData = localStorage.getItem('ai-financial-data');
        if (savedData) {
            const data = JSON.parse(savedData);
            this.portfolioData = new Map(data.portfolio || []);
            this.budgetTracker = new Map(data.budget || []);
        }
        
        // Initialize with sample data if empty
        if (this.portfolioData.size === 0) {
            this.initializeSampleData();
        }
    }

    initializeSampleData() {
        // Sample portfolio data
        this.portfolioData.set('AAPL', {
            symbol: 'AAPL',
            shares: 10,
            avgCost: 150.00,
            currentPrice: 175.00,
            lastUpdated: new Date().toISOString()
        });
        
        this.portfolioData.set('MSFT', {
            symbol: 'MSFT', 
            shares: 5,
            avgCost: 300.00,
            currentPrice: 330.00,
            lastUpdated: new Date().toISOString()
        });

        // Sample budget data
        this.budgetTracker.set('income', {
            monthly: 5000,
            categories: {
                salary: 4500,
                freelance: 500
            }
        });

        this.budgetTracker.set('expenses', {
            monthly: 3200,
            categories: {
                housing: 1500,
                food: 400,
                transport: 300,
                utilities: 200,
                entertainment: 300,
                savings: 500
            }
        });
    }

    async saveFinancialData() {
        const data = {
            portfolio: Array.from(this.portfolioData.entries()),
            budget: Array.from(this.budgetTracker.entries())
        };
        localStorage.setItem('ai-financial-data', JSON.stringify(data));
    }

    // Portfolio Management
    async getPortfolioSummary() {
        if (!this.initialized) await this.initialize();
        
        let totalValue = 0;
        let totalCost = 0;
        const positions = [];

        for (const [symbol, position] of this.portfolioData) {
            const currentValue = position.shares * position.currentPrice;
            const totalCost_pos = position.shares * position.avgCost;
            const gainLoss = currentValue - totalCost_pos;
            const gainLossPercent = ((gainLoss / totalCost_pos) * 100).toFixed(2);

            positions.push({
                symbol,
                shares: position.shares,
                currentPrice: position.currentPrice,
                avgCost: position.avgCost,
                currentValue,
                totalCost: totalCost_pos,
                gainLoss,
                gainLossPercent: `${gainLossPercent}%`
            });

            totalValue += currentValue;
            totalCost += totalCost_pos;
        }

        const totalGainLoss = totalValue - totalCost;
        const totalGainLossPercent = ((totalGainLoss / totalCost) * 100).toFixed(2);

        return {
            totalValue: totalValue.toFixed(2),
            totalCost: totalCost.toFixed(2),
            totalGainLoss: totalGainLoss.toFixed(2),
            totalGainLossPercent: `${totalGainLossPercent}%`,
            positions
        };
    }

    async addPosition(symbol, shares, avgCost) {
        this.portfolioData.set(symbol, {
            symbol,
            shares: parseFloat(shares),
            avgCost: parseFloat(avgCost),
            currentPrice: parseFloat(avgCost), // Will update with real price later
            lastUpdated: new Date().toISOString()
        });
        
        await this.saveFinancialData();
        return `Added ${shares} shares of ${symbol} at $${avgCost}`;
    }

    async updatePrice(symbol, newPrice) {
        if (this.portfolioData.has(symbol)) {
            const position = this.portfolioData.get(symbol);
            position.currentPrice = parseFloat(newPrice);
            position.lastUpdated = new Date().toISOString();
            this.portfolioData.set(symbol, position);
            await this.saveFinancialData();
            return `Updated ${symbol} price to $${newPrice}`;
        }
        return `Symbol ${symbol} not found in portfolio`;
    }

    // Budget Analysis
    async getBudgetAnalysis() {
        if (!this.initialized) await this.initialize();
        
        const income = this.budgetTracker.get('income');
        const expenses = this.budgetTracker.get('expenses');

        if (!income || !expenses) {
            return { error: 'Budget data not available' };
        }

        const netIncome = income.monthly - expenses.monthly;
        const savingsRate = ((netIncome / income.monthly) * 100).toFixed(2);

        // Expense breakdown
        const expenseCategories = Object.entries(expenses.categories).map(([category, amount]) => ({
            category,
            amount,
            percentage: ((amount / expenses.monthly) * 100).toFixed(2) + '%'
        }));

        return {
            monthlyIncome: income.monthly,
            monthlyExpenses: expenses.monthly,
            netIncome,
            savingsRate: `${savingsRate}%`,
            expenseBreakdown: expenseCategories,
            recommendations: this.generateBudgetRecommendations(income, expenses, netIncome)
        };
    }

    generateBudgetRecommendations(income, expenses, netIncome) {
        const recommendations = [];
        
        if (netIncome < 0) {
            recommendations.push('âš ï¸ You are spending more than you earn. Consider reducing expenses.');
        }
        
        const savingsRate = (netIncome / income.monthly) * 100;
        if (savingsRate < 10) {
            recommendations.push('ðŸ’° Try to save at least 10-20% of your income.');
        } else if (savingsRate > 20) {
            recommendations.push('ðŸŽ‰ Great job! You have a healthy savings rate.');
        }

        const housingPercent = (expenses.categories.housing / income.monthly) * 100;
        if (housingPercent > 30) {
            recommendations.push('ðŸ  Housing costs exceed 30% of income. Consider reducing housing expenses.');
        }

        return recommendations;
    }

    // Investment Analysis
    async analyzeInvestmentOpportunity(symbol, price, targetPrice) {
        const currentDate = new Date();
        const analysis = {
            symbol,
            currentPrice: parseFloat(price),
            targetPrice: parseFloat(targetPrice),
            potentialGain: parseFloat(targetPrice) - parseFloat(price),
            potentialGainPercent: (((parseFloat(targetPrice) - parseFloat(price)) / parseFloat(price)) * 100).toFixed(2) + '%',
            analysisDate: currentDate.toISOString(),
            riskAssessment: this.assessRisk(symbol, price, targetPrice),
            recommendation: this.generateInvestmentRecommendation(symbol, price, targetPrice)
        };

        return analysis;
    }

    assessRisk(symbol, currentPrice, targetPrice) {
        const gainPercent = ((targetPrice - currentPrice) / currentPrice) * 100;
        
        if (gainPercent > 50) return 'High Risk - High Reward';
        if (gainPercent > 20) return 'Moderate Risk';
        if (gainPercent > 5) return 'Low Risk';
        return 'Conservative Investment';
    }

    generateInvestmentRecommendation(symbol, currentPrice, targetPrice) {
        const gainPercent = ((targetPrice - currentPrice) / currentPrice) * 100;
        
        if (gainPercent > 20) {
            return `Strong Buy - ${gainPercent.toFixed(2)}% upside potential`;
        } else if (gainPercent > 10) {
            return `Buy - ${gainPercent.toFixed(2)}% upside potential`;
        } else if (gainPercent > 0) {
            return `Hold - ${gainPercent.toFixed(2)}% upside potential`;
        } else {
            return `Sell - ${Math.abs(gainPercent).toFixed(2)}% downside risk`;
        }
    }

    // Expense Tracking
    async addExpense(category, amount, description = '') {
        const expense = {
            id: Date.now(),
            category,
            amount: parseFloat(amount),
            description,
            date: new Date().toISOString()
        };

        // Update budget tracker
        const expenses = this.budgetTracker.get('expenses') || { monthly: 0, categories: {} };
        expenses.categories[category] = (expenses.categories[category] || 0) + parseFloat(amount);
        expenses.monthly += parseFloat(amount);
        this.budgetTracker.set('expenses', expenses);

        await this.saveFinancialData();
        return expense;
    }

    // Financial Goals
    async calculateSavingsGoal(goalAmount, timeframeMonths, currentSavings = 0) {
        const remainingAmount = goalAmount - currentSavings;
        const monthlyRequired = remainingAmount / timeframeMonths;
        
        const income = this.budgetTracker.get('income');
        const expenses = this.budgetTracker.get('expenses');
        
        let feasibility = 'Unknown';
        if (income && expenses) {
            const currentNet = income.monthly - expenses.monthly;
            feasibility = monthlyRequired <= currentNet ? 'Achievable' : 'Challenging';
        }

        return {
            goalAmount,
            currentSavings,
            remainingAmount,
            timeframeMonths,
            monthlyRequired: monthlyRequired.toFixed(2),
            feasibility,
            recommendation: monthlyRequired <= (income?.monthly || 0) * 0.1 ? 
                'This goal fits well within your budget' : 
                'Consider extending timeline or increasing income'
        };
    }
}

// UI Modals
class AIHubModal extends Modal {
    constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        
        contentEl.createEl('h1', { text: 'ðŸ§  AI Superintelligence Hub', cls: 'ai-hub-title' });
        
        this.createControlPanel(contentEl);
        this.createStatusPanel(contentEl);
        this.createAnalyticsPanel(contentEl);
        this.addStyles();
    }

    createControlPanel(container) {
        const controlPanel = container.createDiv('ai-control-panel');
        controlPanel.createEl('h2', { text: 'âš¡ AI Control Center' });

        const buttonGrid = controlPanel.createDiv('button-grid');

        // Main AI Features
        const buttons = [
            { name: 'ðŸ“Š Quick Analysis', action: () => this.plugin.quickAIAnalysis() },
            { name: 'ðŸ’° Financial Intelligence', action: () => this.plugin.openFinancialDashboard() },
            { name: 'ðŸ“„ Document Intelligence', action: () => this.plugin.openDocumentIntelligence() },
            { name: 'ðŸš€ Multi-Feature Launcher', action: () => this.plugin.openMultiLauncher() },
            { name: 'ðŸ§  Memory Insights', action: () => this.showMemoryInsights() },
            { name: 'ðŸŽ¯ Context Analysis', action: () => this.showContextAnalysis() }
        ];

        buttons.forEach(btn => {
            const button = buttonGrid.createEl('button', { text: btn.name, cls: 'ai-button' });
            button.addEventListener('click', btn.action);
        });
    }

    createStatusPanel(container) {
        const statusPanel = container.createDiv('ai-status-panel');
        statusPanel.createEl('h2', { text: 'ðŸ“ˆ System Status' });

        const statusGrid = statusPanel.createDiv('status-grid');
        
        const systems = [
            { name: 'AI Core', status: 'Online', color: '#00ff00' },
            { name: 'Memory System', status: 'Learning', color: '#ffaa00' },
            { name: 'Context Engine', status: 'Active', color: '#00ff00' },
            { name: 'Financial AI', status: 'Monitoring', color: '#00aaff' }
        ];

        systems.forEach(system => {
            const statusItem = statusGrid.createDiv('status-item');
            statusItem.createEl('span', { text: `${system.name}:`, cls: 'status-label' });
            const statusValue = statusItem.createEl('span', { 
                text: system.status, 
                cls: 'status-value' 
            });
            statusValue.style.color = system.color;
        });
    }

    createAnalyticsPanel(container) {
        const analyticsPanel = container.createDiv('ai-analytics-panel');
        analyticsPanel.createEl('h2', { text: 'ðŸ” AI Analytics' });

        // Get real-time analytics
        const memoryInsights = this.plugin.memorySystem.getInsights();
        
        const analyticsGrid = analyticsPanel.createDiv('analytics-grid');
        
        const metrics = [
            { label: 'Total Memories', value: memoryInsights.totalMemories },
            { label: 'Usage Trend', value: memoryInsights.trends },
            { label: 'Active Features', value: '22 Systems Online' },
            { label: 'Intelligence Level', value: 'Superintelligent' }
        ];

        metrics.forEach(metric => {
            const metricItem = analyticsGrid.createDiv('metric-item');
            metricItem.createEl('div', { text: metric.label, cls: 'metric-label' });
            metricItem.createEl('div', { text: metric.value, cls: 'metric-value' });
        });
    }

    async showMemoryInsights() {
        const insights = this.plugin.memorySystem.getInsights();
        new Notice(`ðŸ’¾ Memory Insights: ${insights.totalMemories} memories stored. ${insights.trends}`);
    }

    async showContextAnalysis() {
        const context = await this.plugin.contextEngine.getCurrentContext();
        new Notice(`ðŸŽ¯ Current Context: ${context.summary}`);
    }

    addStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .ai-hub-title {
                text-align: center;
                background: linear-gradient(45deg, #00aaff, #aa00ff);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 20px;
            }
            .ai-control-panel, .ai-status-panel, .ai-analytics-panel {
                margin: 20px 0;
                padding: 15px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 8px;
                background: var(--background-secondary);
            }
            .button-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 10px;
                margin-top: 10px;
            }
            .ai-button {
                padding: 10px 15px;
                background: linear-gradient(45deg, #00aaff, #aa00ff);
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
            }
            .ai-button:hover {
                opacity: 0.8;
                transform: translateY(-2px);
            }
            .status-grid, .analytics-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
                margin-top: 10px;
            }
            .status-item, .metric-item {
                padding: 10px;
                background: var(--background-primary);
                border-radius: 5px;
                text-align: center;
            }
            .status-label, .metric-label {
                font-weight: bold;
                display: block;
                margin-bottom: 5px;
            }
            .status-value, .metric-value {
                font-size: 1.1em;
                font-weight: bold;
            }
        `;
        document.head.appendChild(style);
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

class FinancialDashboardModal extends Modal {
    constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        
        contentEl.createEl('h1', { text: 'ðŸ’° AI Financial Intelligence Dashboard', cls: 'financial-title' });
        
        this.createFinancialTabs(contentEl);
        this.addFinancialStyles();
    }

    createFinancialTabs(container) {
        const tabContainer = container.createDiv('tab-container');
        const tabHeader = tabContainer.createDiv('tab-header');
        const tabContent = tabContainer.createDiv('tab-content');

        const tabs = [
            { name: 'ðŸ“Š Portfolio', id: 'portfolio', content: () => this.createPortfolioTab(tabContent) },
            { name: 'ðŸ’³ Budget', id: 'budget', content: () => this.createBudgetTab(tabContent) },
            { name: 'ðŸ“ˆ Analysis', id: 'analysis', content: () => this.createAnalysisTab(tabContent) },
            { name: 'ðŸŽ¯ Goals', id: 'goals', content: () => this.createGoalsTab(tabContent) }
        ];

        tabs.forEach((tab, index) => {
            const tabBtn = tabHeader.createEl('button', { 
                text: tab.name, 
                cls: `tab-button ${index === 0 ? 'active' : ''}` 
            });
            
            tabBtn.addEventListener('click', () => {
                // Remove active class from all tabs
                tabHeader.querySelectorAll('.tab-button').forEach(btn => btn.removeClass('active'));
                tabBtn.addClass('active');
                
                // Clear content and show new tab
                tabContent.empty();
                tab.content();
            });
        });

        // Show first tab by default
        tabs[0].content();
    }

    async createPortfolioTab(container) {
        const portfolioDiv = container.createDiv('portfolio-tab');
        portfolioDiv.createEl('h2', { text: 'ðŸ“Š Portfolio Overview' });

        try {
            const summary = await this.plugin.financialIntelligence.getPortfolioSummary();
            
            // Summary cards
            const summaryGrid = portfolioDiv.createDiv('summary-grid');
            
            const summaryItems = [
                { label: 'Total Value', value: `${summary.totalValue}`, color: '#00ff00' },
                { label: 'Total Cost', value: `${summary.totalCost}`, color: '#ffffff' },
                { label: 'Total Gain/Loss', value: `${summary.totalGainLoss}`, color: parseFloat(summary.totalGainLoss) >= 0 ? '#00ff00' : '#ff0000' },
                { label: 'Return %', value: summary.totalGainLossPercent, color: parseFloat(summary.totalGainLoss) >= 0 ? '#00ff00' : '#ff0000' }
            ];

            summaryItems.forEach(item => {
                const card = summaryGrid.createDiv('summary-card');
                card.createEl('div', { text: item.label, cls: 'summary-label' });
                const valueEl = card.createEl('div', { text: item.value, cls: 'summary-value' });
                valueEl.style.color = item.color;
            });

            // Positions table
            const tableContainer = portfolioDiv.createDiv('positions-table');
            tableContainer.createEl('h3', { text: 'ðŸ“‹ Current Positions' });
            
            const table = tableContainer.createEl('table', { cls: 'portfolio-table' });
            const thead = table.createEl('thead');
            const tbody = table.createEl('tbody');

            // Table headers
            const headerRow = thead.createEl('tr');
            ['Symbol', 'Shares', 'Avg Cost', 'Current Price', 'Current Value', 'Gain/Loss', '%'].forEach(header => {
                headerRow.createEl('th', { text: header });
            });

            // Table rows
            summary.positions.forEach(position => {
                const row = tbody.createEl('tr');
                row.createEl('td', { text: position.symbol, cls: 'symbol-cell' });
                row.createEl('td', { text: position.shares });
                row.createEl('td', { text: `${position.avgCost.toFixed(2)}` });
                row.createEl('td', { text: `${position.currentPrice.toFixed(2)}` });
                row.createEl('td', { text: `${position.currentValue.toFixed(2)}` });
                
                const gainLossCell = row.createEl('td', { text: `${position.gainLoss.toFixed(2)}` });
                const percentCell = row.createEl('td', { text: position.gainLossPercent });
                
                const color = position.gainLoss >= 0 ? '#00ff00' : '#ff0000';
                gainLossCell.style.color = color;
                percentCell.style.color = color;
            });

        } catch (error) {
            portfolioDiv.createEl('p', { text: 'Error loading portfolio data', cls: 'error-text' });
        }

        // Add position form
        const addForm = portfolioDiv.createDiv('add-position-form');
        addForm.createEl('h3', { text: 'âž• Add New Position' });
        
        const formGrid = addForm.createDiv('form-grid');
        const symbolInput = formGrid.createEl('input', { placeholder: 'Symbol (e.g., AAPL)', cls: 'financial-input' });
        const sharesInput = formGrid.createEl('input', { placeholder: 'Shares', type: 'number', cls: 'financial-input' });
        const priceInput = formGrid.createEl('input', { placeholder: 'Avg Cost', type: 'number', step: '0.01', cls: 'financial-input' });
        
        const addButton = formGrid.createEl('button', { text: 'ðŸ’¼ Add Position', cls: 'financial-button' });
        addButton.addEventListener('click', async () => {
            if (symbolInput.value && sharesInput.value && priceInput.value) {
                const result = await this.plugin.financialIntelligence.addPosition(
                    symbolInput.value.toUpperCase(),
                    sharesInput.value,
                    priceInput.value
                );
                new Notice(result);
                symbolInput.value = '';
                sharesInput.value = '';
                priceInput.value = '';
                this.createPortfolioTab(container); // Refresh
            }
        });
    }

    async createBudgetTab(container) {
        const budgetDiv = container.createDiv('budget-tab');
        budgetDiv.createEl('h2', { text: 'ðŸ’³ Budget Analysis' });

        try {
            const analysis = await this.plugin.financialIntelligence.getBudgetAnalysis();
            
            if (analysis.error) {
                budgetDiv.createEl('p', { text: analysis.error, cls: 'error-text' });
                return;
            }

            // Budget overview
            const overviewGrid = budgetDiv.createDiv('budget-overview-grid');
            
            const overviewItems = [
                { label: 'Monthly Income', value: `${analysis.monthlyIncome}`, color: '#00ff00' },
                { label: 'Monthly Expenses', value: `${analysis.monthlyExpenses}`, color: '#ff6600' },
                { label: 'Net Income', value: `${analysis.netIncome}`, color: analysis.netIncome >= 0 ? '#00ff00' : '#ff0000' },
                { label: 'Savings Rate', value: analysis.savingsRate, color: '#00aaff' }
            ];

            overviewItems.forEach(item => {
                const card = overviewGrid.createDiv('budget-card');
                card.createEl('div', { text: item.label, cls: 'budget-label' });
                const valueEl = card.createEl('div', { text: item.value, cls: 'budget-value' });
                valueEl.style.color = item.color;
            });

            // Expense breakdown
            const expenseDiv = budgetDiv.createDiv('expense-breakdown');
            expenseDiv.createEl('h3', { text: 'ðŸ“Š Expense Breakdown' });
            
            const expenseGrid = expenseDiv.createDiv('expense-grid');
            analysis.expenseBreakdown.forEach(expense => {
                const expenseItem = expenseGrid.createDiv('expense-item');
                expenseItem.createEl('div', { text: expense.category.charAt(0).toUpperCase() + expense.category.slice(1), cls: 'expense-category' });
                expenseItem.createEl('div', { text: `${expense.amount}`, cls: 'expense-amount' });
                expenseItem.createEl('div', { text: expense.percentage, cls: 'expense-percentage' });
            });

            // Recommendations
            if (analysis.recommendations.length > 0) {
                const recommendationsDiv = budgetDiv.createDiv('recommendations');
                recommendationsDiv.createEl('h3', { text: 'ðŸ’¡ AI Recommendations' });
                
                analysis.recommendations.forEach(rec => {
                    const recItem = recommendationsDiv.createDiv('recommendation-item');
                    recItem.createEl('p', { text: rec });
                });
            }

        } catch (error) {
            budgetDiv.createEl('p', { text: 'Error loading budget data', cls: 'error-text' });
        }
    }

    async createAnalysisTab(container) {
        const analysisDiv = container.createDiv('analysis-tab');
        analysisDiv.createEl('h2', { text: 'ðŸ“ˆ Investment Analysis' });

        // Analysis form
        const analysisForm = analysisDiv.createDiv('analysis-form');
        analysisForm.createEl('h3', { text: 'ðŸ” Analyze Investment Opportunity' });
        
        const formGrid = analysisForm.createDiv('form-grid');
        const symbolInput = formGrid.createEl('input', { placeholder: 'Symbol (e.g., TSLA)', cls: 'financial-input' });
        const currentPriceInput = formGrid.createEl('input', { placeholder: 'Current Price', type: 'number', step: '0.01', cls: 'financial-input' });
        const targetPriceInput = formGrid.createEl('input', { placeholder: 'Target Price', type: 'number', step: '0.01', cls: 'financial-input' });
        
        const analyzeButton = formGrid.createEl('button', { text: 'ðŸš€ Analyze', cls: 'financial-button' });
        
        const resultDiv = analysisDiv.createDiv('analysis-result');

        analyzeButton.addEventListener('click', async () => {
            if (symbolInput.value && currentPriceInput.value && targetPriceInput.value) {
                const analysis = await this.plugin.financialIntelligence.analyzeInvestmentOpportunity(
                    symbolInput.value.toUpperCase(),
                    currentPriceInput.value,
                    targetPriceInput.value
                );

                resultDiv.empty();
                resultDiv.createEl('h3', { text: `ðŸ“Š Analysis Results for ${analysis.symbol}` });
                
                const resultGrid = resultDiv.createDiv('analysis-result-grid');
                
                const resultItems = [
                    { label: 'Current Price', value: `${analysis.currentPrice}` },
                    { label: 'Target Price', value: `${analysis.targetPrice}` },
                    { label: 'Potential Gain', value: `${analysis.potentialGain.toFixed(2)}` },
                    { label: 'Potential Return', value: analysis.potentialGainPercent },
                    { label: 'Risk Assessment', value: analysis.riskAssessment },
                    { label: 'AI Recommendation', value: analysis.recommendation }
                ];

                resultItems.forEach(item => {
                    const resultItem = resultGrid.createDiv('result-item');
                    resultItem.createEl('div', { text: item.label, cls: 'result-label' });
                    resultItem.createEl('div', { text: item.value, cls: 'result-value' });
                });
            }
        });
    }

    async createGoalsTab(container) {
        const goalsDiv = container.createDiv('goals-tab');
        goalsDiv.createEl('h2', { text: 'ðŸŽ¯ Financial Goals' });

        // Goals calculator
        const calculatorForm = goalsDiv.createDiv('goals-calculator');
        calculatorForm.createEl('h3', { text: 'ðŸ“Š Savings Goal Calculator' });
        
        const formGrid = calculatorForm.createDiv('form-grid');
        const goalAmountInput = formGrid.createEl('input', { placeholder: 'Goal Amount ($)', type: 'number', cls: 'financial-input' });
        const timeframeInput = formGrid.createEl('input', { placeholder: 'Timeframe (months)', type: 'number', cls: 'financial-input' });
        const currentSavingsInput = formGrid.createEl('input', { placeholder: 'Current Savings ($)', type: 'number', cls: 'financial-input' });
        
        const calculateButton = formGrid.createEl('button', { text: 'ðŸŽ¯ Calculate', cls: 'financial-button' });
        
        const goalResultDiv = goalsDiv.createDiv('goal-result');

        calculateButton.addEventListener('click', async () => {
            if (goalAmountInput.value && timeframeInput.value) {
                const result = await this.plugin.financialIntelligence.calculateSavingsGoal(
                    parseFloat(goalAmountInput.value),
                    parseInt(timeframeInput.value),
                    parseFloat(currentSavingsInput.value) || 0
                );

                goalResultDiv.empty();
                goalResultDiv.createEl('h3', { text: 'ðŸŽ¯ Savings Goal Analysis' });
                
                const goalGrid = goalResultDiv.createDiv('goal-result-grid');
                
                const goalItems = [
                    { label: 'Goal Amount', value: `${result.goalAmount}` },
                    { label: 'Current Savings', value: `${result.currentSavings}` },
                    { label: 'Remaining Needed', value: `${result.remainingAmount}` },
                    { label: 'Monthly Required', value: `${result.monthlyRequired}` },
                    { label: 'Feasibility', value: result.feasibility },
                    { label: 'AI Recommendation', value: result.recommendation }
                ];

                goalItems.forEach(item => {
                    const goalItem = goalGrid.createDiv('goal-item');
                    goalItem.createEl('div', { text: item.label, cls: 'goal-label' });
                    goalItem.createEl('div', { text: item.value, cls: 'goal-value' });
                });
            }
        });
    }

    addFinancialStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .financial-title {
                text-align: center;
                background: linear-gradient(45deg, #00ff00, #ffaa00);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 20px;
            }
            .tab-container {
                margin: 20px 0;
            }
            .tab-header {
                display: flex;
                border-bottom: 2px solid var(--background-modifier-border);
                margin-bottom: 20px;
            }
            .tab-button {
                padding: 10px 20px;
                background: none;
                border: none;
                cursor: pointer;
                border-bottom: 2px solid transparent;
                font-weight: bold;
            }
            .tab-button.active {
                border-bottom-color: #00aaff;
                color: #00aaff;
            }
            .summary-grid, .budget-overview-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
                margin: 20px 0;
            }
            .summary-card, .budget-card {
                padding: 15px;
                background: var(--background-secondary);
                border-radius: 8px;
                text-align: center;
                border: 1px solid var(--background-modifier-border);
            }
            .summary-label, .budget-label {
                font-size: 0.9em;
                opacity: 0.8;
                margin-bottom: 5px;
            }
            .summary-value, .budget-value {
                font-size: 1.3em;
                font-weight: bold;
            }
            .portfolio-table {
                width: 100%;
                border-collapse: collapse;
                margin: 20px 0;
            }
            .portfolio-table th, .portfolio-table td {
                padding: 10px;
                border: 1px solid var(--background-modifier-border);
                text-align: center;
            }
            .portfolio-table th {
                background: var(--background-secondary);
                font-weight: bold;
            }
            .symbol-cell {
                font-weight: bold;
                color: #00aaff;
            }
            .form-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
                margin: 15px 0;
            }
            .financial-input {
                padding: 8px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 4px;
                background: var(--background-primary);
            }
            .financial-button {
                padding: 8px 15px;
                background: linear-gradient(45deg, #00aaff, #00ff00);
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            }
            .financial-button:hover {
                opacity: 0.8;
            }
            .expense-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 10px;
                margin: 15px 0;
            }
            .expense-item {
                padding: 10px;
                background: var(--background-secondary);
                border-radius: 5px;
                text-align: center;
            }
            .expense-category {
                font-weight: bold;
                margin-bottom: 5px;
            }
            .expense-amount {
                color: #ff6600;
                font-size: 1.1em;
            }
            .expense-percentage {
                font-size: 0.9em;
                opacity: 0.8;
            }
            .recommendations {
                margin: 20px 0;
                padding: 15px;
                background: var(--background-secondary);
                border-radius: 8px;
            }
            .recommendation-item {
                padding: 8px;
                margin: 5px 0;
                background: var(--background-primary);
                border-radius: 4px;
                border-left: 3px solid #00aaff;
            }
            .analysis-result-grid, .goal-result-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 10px;
                margin: 15px 0;
            }
            .result-item, .goal-item {
                padding: 10px;
                background: var(--background-secondary);
                border-radius: 5px;
            }
            .result-label, .goal-label {
                font-weight: bold;
                margin-bottom: 5px;
                font-size: 0.9em;
                opacity: 0.8;
            }
            .result-value, .goal-value {
                color: #00aaff;
                font-weight: bold;
            }
            .error-text {
                color: #ff0000;
                font-style: italic;
                text-align: center;
                margin: 20px 0;
            }
        `;
        document.head.appendChild(style);
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

class QuickAnalysisModal extends Modal {
    constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        
        contentEl.createEl('h1', { text: 'âš¡ AI Quick Analysis', cls: 'analysis-title' });
        
        this.createAnalysisInterface(contentEl);
        this.addAnalysisStyles();
    }

    createAnalysisInterface(container) {
        // Current file analysis
        const currentFileDiv = container.createDiv('current-file-analysis');
        currentFileDiv.createEl('h2', { text: 'ðŸ“„ Current File Analysis' });
        
        const analyzeCurrentButton = currentFileDiv.createEl('button', { 
            text: 'ðŸ” Analyze Current File', 
            cls: 'analysis-button' 
        });
        
        const currentResultDiv = currentFileDiv.createDiv('analysis-result');

        analyzeCurrentButton.addEventListener('click', async () => {
            await this.analyzeCurrentFile(currentResultDiv);
        });

        // Custom text analysis
        const customAnalysisDiv = container.createDiv('custom-analysis');
        customAnalysisDiv.createEl('h2', { text: 'âœï¸ Custom Text Analysis' });
        
        const textArea = customAnalysisDiv.createEl('textarea', { 
            placeholder: 'Enter text to analyze...',
            cls: 'analysis-textarea'
        });
        
        const analyzeCustomButton = customAnalysisDiv.createEl('button', { 
            text: 'ðŸš€ Analyze Text', 
            cls: 'analysis-button' 
        });
        
        const customResultDiv = customAnalysisDiv.createDiv('analysis-result');

        analyzeCustomButton.addEventListener('click', async () => {
            if (textArea.value.trim()) {
                await this.analyzeCustomText(textArea.value, customResultDiv);
            }
        });

        // Context analysis
        const contextDiv = container.createDiv('context-analysis');
        contextDiv.createEl('h2', { text: 'ðŸŽ¯ Context Analysis' });
        
        const analyzeContextButton = contextDiv.createEl('button', { 
            text: 'ðŸ“Š Analyze Current Context', 
            cls: 'analysis-button' 
        });
        
        const contextResultDiv = contextDiv.createDiv('analysis-result');

        analyzeContextButton.addEventListener('click', async () => {
            await this.analyzeContext(contextResultDiv);
        });
    }

    async analyzeCurrentFile(resultDiv) {
        resultDiv.empty();
        resultDiv.createEl('div', { text: 'ðŸ”„ Analyzing...', cls: 'loading-text' });

        const activeLeaf = this.plugin.app.workspace.activeLeaf;
        if (!activeLeaf || !activeLeaf.view.file) {
            resultDiv.empty();
            resultDiv.createEl('p', { text: 'No active file to analyze', cls: 'error-text' });
            return;
        }

        try {
            const file = activeLeaf.view.file;
            const content = await this.plugin.app.vault.read(file);
            const analysis = await this.plugin.aiCore.analyzeContent(content);

            // Record this interaction
            this.plugin.memorySystem.recordInteraction('file_analysis', {
                fileName: file.name,
                analysis: analysis
            });

            this.displayAnalysisResult(resultDiv, analysis, file.name);
        } catch (error) {
            resultDiv.empty();
            resultDiv.createEl('p', { text: 'Error analyzing file', cls: 'error-text' });
        }
    }

    async analyzeCustomText(text, resultDiv) {
        resultDiv.empty();
        resultDiv.createEl('div', { text: 'ðŸ”„ Analyzing...', cls: 'loading-text' });

        try {
            const analysis = await this.plugin.aiCore.analyzeContent(text);

            // Record this interaction
            this.plugin.memorySystem.recordInteraction('custom_analysis', {
                textLength: text.length,
                analysis: analysis
            });

            this.displayAnalysisResult(resultDiv, analysis, 'Custom Text');
        } catch (error) {
            resultDiv.empty();
            resultDiv.createEl('p', { text: 'Error analyzing text', cls: 'error-text' });
        }
    }

    async analyzeContext(resultDiv) {
        resultDiv.empty();
        resultDiv.createEl('div', { text: 'ðŸ”„ Analyzing context...', cls: 'loading-text' });

        try {
            await this.plugin.contextEngine.updateContext();
            const context = await this.plugin.contextEngine.getCurrentContext();

            resultDiv.empty();
            resultDiv.createEl('h3', { text: 'ðŸŽ¯ Context Analysis Results' });

            const contextGrid = resultDiv.createDiv('context-grid');

            // Context summary
            const summaryCard = contextGrid.createDiv('context-card');
            summaryCard.createEl('h4', { text: 'ðŸ“‹ Summary' });
            summaryCard.createEl('p', { text: context.summary });

            // File context
            if (context.details.currentFile) {
                const fileCard = contextGrid.createDiv('context-card');
                fileCard.createEl('h4', { text: 'ðŸ“„ Current File' });
                fileCard.createEl('p', { text: `Name: ${context.details.currentFile.name}` });
                fileCard.createEl('p', { text: `Size: ${(context.details.currentFile.size / 1024).toFixed(2)} KB` });
                fileCard.createEl('p', { text: `Modified: ${new Date(context.details.currentFile.modified).toLocaleString()}` });
            }

            // Time context
            const timeCard = contextGrid.createDiv('context-card');
            timeCard.createEl('h4', { text: 'â° Time Context' });
            timeCard.createEl('p', { text: `${context.details.timeContext.timeOfDay} on ${context.details.timeContext.dayOfWeek}` });
            timeCard.createEl('p', { text: `Date: ${context.details.timeContext.date}` });

            // Vault stats
            const vaultCard = contextGrid.createDiv('context-card');
            vaultCard.createEl('h4', { text: 'ðŸ“‚ Vault Stats' });
            vaultCard.createEl('p', { text: `Notes: ${context.details.vaultStats.markdownFiles}` });
            vaultCard.createEl('p', { text: `Total Files: ${context.details.vaultStats.totalFiles}` });
            vaultCard.createEl('p', { text: `Size: ${(context.details.vaultStats.totalSize / 1024 / 1024).toFixed(2)} MB` });

        } catch (error) {
            resultDiv.empty();
            resultDiv.createEl('p', { text: 'Error analyzing context', cls: 'error-text' });
        }
    }

    displayAnalysisResult(container, analysis, fileName) {
        container.empty();
        container.createEl('h3', { text: `ðŸ“Š Analysis Results for: ${fileName}` });

        const analysisGrid = container.createDiv('analysis-grid');

        // Basic metrics
        const metricsCard = analysisGrid.createDiv('analysis-card');
        metricsCard.createEl('h4', { text: 'ðŸ“ˆ Metrics' });
        metricsCard.createEl('p', { text: `Word Count: ${analysis.wordCount}` });
        metricsCard.createEl('p', { text: `Complexity: ${analysis.complexity}` });
        metricsCard.createEl('p', { text: `Readability: ${analysis.readability}` });

        // Sentiment analysis
        const sentimentCard = analysisGrid.createDiv('analysis-card');
        sentimentCard.createEl('h4', { text: 'ðŸ˜Š Sentiment' });
        const sentimentEl = sentimentCard.createEl('p', { text: `Sentiment: ${analysis.sentiment}` });
        sentimentEl.style.color = analysis.sentiment === 'Positive' ? '#00ff00' : 
                                 analysis.sentiment === 'Negative' ? '#ff0000' : '#ffaa00';

        // Topics
        if (analysis.topics.length > 0) {
            const topicsCard = analysisGrid.createDiv('analysis-card');
            topicsCard.createEl('h4', { text: 'ðŸ·ï¸ Key Topics' });
            analysis.topics.forEach(topic => {
                const topicEl = topicsCard.createEl('span', { 
                    text: topic, 
                    cls: 'topic-tag' 
                });
            });
        }

        // AI insights
        const insightsCard = analysisGrid.createDiv('analysis-card');
        insightsCard.createEl('h4', { text: 'ðŸ§  AI Insights' });
        insightsCard.createEl('p', { text: this.generateInsights(analysis) });
    }

    generateInsights(analysis) {
        const insights = [];
        
        if (analysis.wordCount > 1000) {
            insights.push('This is a substantial document');
        } else if (analysis.wordCount < 100) {
            insights.push('This is a brief document');
        }

        if (analysis.complexity === 'Complex') {
            insights.push('Uses sophisticated language structure');
        } else if (analysis.complexity === 'Simple') {
            insights.push('Uses clear, straightforward language');
        }

        if (analysis.sentiment === 'Positive') {
            insights.push('Overall positive tone detected');
        } else if (analysis.sentiment === 'Negative') {
            insights.push('Some negative sentiment present');
        }

        if (analysis.topics.length > 3) {
            insights.push('Covers multiple diverse topics');
        }

        return insights.length > 0 ? insights.join('. ') + '.' : 'Standard document structure detected.';
    }

    addAnalysisStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .analysis-title {
                text-align: center;
                background: linear-gradient(45deg, #ff6600, #ffaa00);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 20px;
            }
            .current-file-analysis, .custom-analysis, .context-analysis {
                margin: 20px 0;
                padding: 15px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 8px;
                background: var(--background-secondary);
            }
            .analysis-button {
                padding: 10px 20px;
                background: linear-gradient(45deg, #ff6600, #ffaa00);
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
                margin: 10px 0;
            }
            .analysis-button:hover {
                opacity: 0.8;
                transform: translateY(-1px);
            }
            .analysis-textarea {
                width: 100%;
                min-height: 120px;
                padding: 10px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 5px;
                background: var(--background-primary);
                font-family: var(--font-monospace);
                resize: vertical;
                margin: 10px 0;
            }
            .analysis-grid, .context-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
                margin: 15px 0;
            }
            .analysis-card, .context-card {
                padding: 15px;
                background: var(--background-primary);
                border-radius: 8px;
                border: 1px solid var(--background-modifier-border);
            }
            .analysis-card h4, .context-card h4 {
                margin: 0 0 10px 0;
                color: #00aaff;
            }
            .topic-tag {
                display: inline-block;
                padding: 3px 8px;
                margin: 2px;
                background: #00aaff;
                color: white;
                border-radius: 12px;
                font-size: 0.8em;
                font-weight: bold;
            }
            .loading-text {
                text-align: center;
                font-style: italic;
                color: #ffaa00;
                margin: 20px 0;
            }
            .error-text {
                color: #ff0000;
                font-style: italic;
                text-align: center;
                margin: 20px 0;
            }
        `;
        document.head.appendChild(style);
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

class DocumentIntelligenceModal extends Modal {
    constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        
        contentEl.createEl('h1', { text: 'ðŸ“„ AI Document Intelligence', cls: 'document-title' });
        
        this.createDocumentInterface(contentEl);
        this.addDocumentStyles();
    }

    createDocumentInterface(container) {
        // Document search and analysis
        const searchDiv = container.createDiv('document-search');
        searchDiv.createEl('h2', { text: 'ðŸ” Intelligent Document Search' });
        
        const searchInput = searchDiv.createEl('input', { 
            placeholder: 'Search your vault with AI...',
            cls: 'document-search-input'
        });
        
        const searchButton = searchDiv.createEl('button', { 
            text: 'ðŸš€ AI Search', 
            cls: 'document-button' 
        });
        
        const searchResults = searchDiv.createDiv('search-results');

        searchButton.addEventListener('click', async () => {
            if (searchInput.value.trim()) {
                await this.performIntelligentSearch(searchInput.value, searchResults);
            }
        });

        // Document comparison
        const compareDiv = container.createDiv('document-compare');
        compareDiv.createEl('h2', { text: 'âš–ï¸ Document Comparison' });
        
        const compareGrid = compareDiv.createDiv('compare-grid');
        const file1Select = compareGrid.createEl('select', { cls: 'file-select' });
        const file2Select = compareGrid.createEl('select', { cls: 'file-select' });
        
        // Populate file selects
        this.populateFileSelects(file1Select, file2Select);
        
        const compareButton = compareGrid.createEl('button', { 
            text: 'ðŸ”„ Compare Documents', 
            cls: 'document-button' 
        });
        
        const compareResults = compareDiv.createDiv('compare-results');

        compareButton.addEventListener('click', async () => {
            if (file1Select.value && file2Select.value && file1Select.value !== file2Select.value) {
                await this.compareDocuments(file1Select.value, file2Select.value, compareResults);
            }
        });

        // Document insights
        const insightsDiv = container.createDiv('document-insights');
        insightsDiv.createEl('h2', { text: 'ðŸ’¡ Vault Insights' });
        
        const generateInsightsButton = insightsDiv.createEl('button', { 
            text: 'ðŸ§  Generate Vault Insights', 
            cls: 'document-button' 
        });
        
        const insightsResults = insightsDiv.createDiv('insights-results');

        generateInsightsButton.addEventListener('click', async () => {
            await this.generateVaultInsights(insightsResults);
        });

        // Document suggestions
        const suggestionsDiv = container.createDiv('document-suggestions');
        suggestionsDiv.createEl('h2', { text: 'âœ¨ AI Suggestions' });
        
        const suggestButton = suggestionsDiv.createEl('button', { 
            text: 'ðŸŽ¯ Get Document Suggestions', 
            cls: 'document-button' 
        });
        
        const suggestionsResults = suggestionsDiv.createDiv('suggestions-results');

        suggestButton.addEventListener('click', async () => {
            await this.generateDocumentSuggestions(suggestionsResults);
        });
    }

    async populateFileSelects(select1, select2) {
        const files = this.plugin.app.vault.getMarkdownFiles();
        
        // Add default option
        const defaultOption1 = select1.createEl('option', { text: 'Select first document...' });
        defaultOption1.value = '';
        const defaultOption2 = select2.createEl('option', { text: 'Select second document...' });
        defaultOption2.value = '';
        
        files.slice(0, 20).forEach(file => { // Limit to first 20 files for performance
            const option1 = select1.createEl('option', { text: file.basename });
            option1.value = file.path;
            
            const option2 = select2.createEl('option', { text: file.basename });
            option2.value = file.path;
        });
    }

    async performIntelligentSearch(query, resultsDiv) {
        resultsDiv.empty();
        resultsDiv.createEl('div', { text: 'ðŸ”„ Searching...', cls: 'loading-text' });

        try {
            const files = this.plugin.app.vault.getMarkdownFiles();
            const searchResults = [];
            
            // Simple search implementation - in a real implementation, this would use more sophisticated AI
            for (const file of files.slice(0, 50)) { // Limit search for performance
                try {
                    const content = await this.plugin.app.vault.read(file);
                    const lowerContent = content.toLowerCase();
                    const lowerQuery = query.toLowerCase();
                    
                    if (lowerContent.includes(lowerQuery)) {
                        const analysis = await this.plugin.aiCore.analyzeContent(content);
                        const relevanceScore = this.calculateRelevance(content, query);
                        
                        searchResults.push({
                            file,
                            content,
                            analysis,
                            relevanceScore,
                            snippet: this.extractSnippet(content, query)
                        });
                    }
                } catch (error) {
                    // Skip files that can't be read
                    continue;
                }
            }

            // Sort by relevance
            searchResults.sort((a, b) => b.relevanceScore - a.relevanceScore);

            this.displaySearchResults(resultsDiv, searchResults.slice(0, 10), query);

            // Record search interaction
            this.plugin.memorySystem.recordInteraction('document_search', {
                query,
                resultsCount: searchResults.length
            });

        } catch (error) {
            resultsDiv.empty();
            resultsDiv.createEl('p', { text: 'Error performing search', cls: 'error-text' });
        }
    }

    calculateRelevance(content, query) {
        const lowerContent = content.toLowerCase();
        const lowerQuery = query.toLowerCase();
        const queryWords = lowerQuery.split(/\s+/);
        
        let score = 0;
        queryWords.forEach(word => {
            const regex = new RegExp(word, 'gi');
            const matches = content.match(regex);
            if (matches) {
                score += matches.length;
            }
        });

        return score;
    }

    extractSnippet(content, query, snippetLength = 200) {
        const lowerContent = content.toLowerCase();
        const lowerQuery = query.toLowerCase();
        const index = lowerContent.indexOf(lowerQuery);
        
        if (index === -1) return content.substring(0, snippetLength) + '...';
        
        const start = Math.max(0, index - 50);
        const end = Math.min(content.length, index + query.length + 150);
        
        return (start > 0 ? '...' : '') + content.substring(start, end) + (end < content.length ? '...' : '');
    }

    displaySearchResults(container, results, query) {
        container.empty();
        
        if (results.length === 0) {
            container.createEl('p', { text: `No results found for "${query}"`, cls: 'no-results' });
            return;
        }

        container.createEl('h3', { text: `ðŸŽ¯ Found ${results.length} results for "${query}"` });
        
        const resultsGrid = container.createDiv('search-results-grid');
        
        results.forEach(result => {
            const resultCard = resultsGrid.createDiv('search-result-card');
            
            // File name and link
            const titleEl = resultCard.createEl('h4', { text: result.file.basename, cls: 'result-title' });
            titleEl.addEventListener('click', () => {
                this.plugin.app.workspace.openLinkText(result.file.path, '', false);
            });
            
            // Snippet
            resultCard.createEl('p', { text: result.snippet, cls: 'result-snippet' });
            
            // Analysis info
            const infoDiv = resultCard.createDiv('result-info');
            infoDiv.createEl('span', { text: `Words: ${result.analysis.wordCount}`, cls: 'info-tag' });
            infoDiv.createEl('span', { text: `Sentiment: ${result.analysis.sentiment}`, cls: 'info-tag' });
            infoDiv.createEl('span', { text: `Relevance: ${result.relevanceScore}`, cls: 'info-tag' });
        });
    }

    async compareDocuments(path1, path2, resultsDiv) {
        resultsDiv.empty();
        resultsDiv.createEl('div', { text: 'ðŸ”„ Comparing documents...', cls: 'loading-text' });

        try {
            const file1 = this.plugin.app.vault.getAbstractFileByPath(path1);
            const file2 = this.plugin.app.vault.getAbstractFileByPath(path2);
            
            if (!file1 || !file2) {
                resultsDiv.empty();
                resultsDiv.createEl('p', { text: 'Could not find selected documents', cls: 'error-text' });
                return;
            }

            const content1 = await this.plugin.app.vault.read(file1);
            const content2 = await this.plugin.app.vault.read(file2);
            
            const analysis1 = await this.plugin.aiCore.analyzeContent(content1);
            const analysis2 = await this.plugin.aiCore.analyzeContent(content2);

            this.displayComparison(resultsDiv, file1, file2, analysis1, analysis2, content1, content2);

            // Record comparison interaction
            this.plugin.memorySystem.recordInteraction('document_comparison', {
                file1: file1.basename,
                file2: file2.basename
            });

        } catch (error) {
            resultsDiv.empty();
            resultsDiv.createEl('p', { text: 'Error comparing documents', cls: 'error-text' });
        }
    }

    displayComparison(container, file1, file2, analysis1, analysis2, content1, content2) {
        container.empty();
        container.createEl('h3', { text: `âš–ï¸ Comparing "${file1.basename}" vs "${file2.basename}"` });

        const comparisonGrid = container.createDiv('comparison-grid');

        // Metrics comparison
        const metricsCard = comparisonGrid.createDiv('comparison-card');
        metricsCard.createEl('h4', { text: 'ðŸ“Š Metrics Comparison' });
        
        const metricsTable = metricsCard.createEl('table', { cls: 'comparison-table' });
        const thead = metricsTable.createEl('thead');
        const tbody = metricsTable.createEl('tbody');

        // Table headers
        const headerRow = thead.createEl('tr');
        headerRow.createEl('th', { text: 'Metric' });
        headerRow.createEl('th', { text: file1.basename });
        headerRow.createEl('th', { text: file2.basename });

        // Comparison rows
        const metrics = [
            { label: 'Word Count', val1: analysis1.wordCount, val2: analysis2.wordCount },
            { label: 'Complexity', val1: analysis1.complexity, val2: analysis2.complexity },
            { label: 'Sentiment', val1: analysis1.sentiment, val2: analysis2.sentiment },
            { label: 'Readability', val1: analysis1.readability, val2: analysis2.readability }
        ];

        metrics.forEach(metric => {
            const row = tbody.createEl('tr');
            row.createEl('td', { text: metric.label, cls: 'metric-label' });
            row.createEl('td', { text: metric.val1 });
            row.createEl('td', { text: metric.val2 });
        });

        // Topics comparison
        const topicsCard = comparisonGrid.createDiv('comparison-card');
        topicsCard.createEl('h4', { text: 'ðŸ·ï¸ Topics Comparison' });
        
        const topicsGrid = topicsCard.createDiv('topics-comparison-grid');
        
        const topics1Div = topicsGrid.createDiv('topics-column');
        topics1Div.createEl('h5', { text: file1.basename });
        analysis1.topics.forEach(topic => {
            topics1Div.createEl('span', { text: topic, cls: 'topic-tag' });
        });

        const topics2Div = topicsGrid.createDiv('topics-column');
        topics2Div.createEl('h5', { text: file2.basename });
        analysis2.topics.forEach(topic => {
            topics2Div.createEl('span', { text: topic, cls: 'topic-tag' });
        });

        // Similarity analysis
        const similarityCard = comparisonGrid.createDiv('comparison-card');
        similarityCard.createEl('h4', { text: 'ðŸ”— Similarity Analysis' });
        
        const similarity = this.calculateSimilarity(content1, content2);
        const commonTopics = analysis1.topics.filter(topic => analysis2.topics.includes(topic));
        
        similarityCard.createEl('p', { text: `Content Similarity: ${similarity}%` });
        similarityCard.createEl('p', { text: `Common Topics: ${commonTopics.length}` });
        
        if (commonTopics.length > 0) {
            const commonDiv = similarityCard.createDiv('common-topics');
            commonDiv.createEl('p', { text: 'Shared Topics:' });
            commonTopics.forEach(topic => {
                commonDiv.createEl('span', { text: topic, cls: 'topic-tag common' });
            });
        }
    }

    calculateSimilarity(content1, content2) {
        const words1 = new Set(content1.toLowerCase().match(/\b\w+\b/g) || []);
        const words2 = new Set(content2.toLowerCase().match(/\b\w+\b/g) || []);
        
        const intersection = new Set([...words1].filter(word => words2.has(word)));
        const union = new Set([...words1, ...words2]);
        
        return Math.round((intersection.size / union.size) * 100);
    }

    async generateVaultInsights(resultsDiv) {
        resultsDiv.empty();
        resultsDiv.createEl('div', { text: 'ðŸ”„ Generating insights...', cls: 'loading-text' });

        try {
            const files = this.plugin.app.vault.getMarkdownFiles();
            const insights = {
                totalFiles: files.length,
                totalWords: 0,
                sentimentDistribution: { Positive: 0, Negative: 0, Neutral: 0 },
                complexityDistribution: { Simple: 0, Moderate: 0, Complex: 0 },
                commonTopics: new Map(),
                recentActivity: []
            };

            // Analyze a sample of files
            const sampleSize = Math.min(50, files.length);
            const sampleFiles = files
                .sort((a, b) => b.stat.mtime - a.stat.mtime)
                .slice(0, sampleSize);

            for (const file of sampleFiles) {
                try {
                    const content = await this.plugin.app.vault.read(file);
                    const analysis = await this.plugin.aiCore.analyzeContent(content);
                    
                    insights.totalWords += analysis.wordCount;
                    insights.sentimentDistribution[analysis.sentiment]++;
                    insights.complexityDistribution[analysis.complexity]++;
                    
                    analysis.topics.forEach(topic => {
                        insights.commonTopics.set(topic, (insights.commonTopics.get(topic) || 0) + 1);
                    });

                    if (Date.now() - file.stat.mtime < (7 * 24 * 60 * 60 * 1000)) {
                        insights.recentActivity.push({
                            name: file.basename,
                            modified: new Date(file.stat.mtime).toLocaleDateString()
                        });
                    }
                } catch (error) {
                    continue;
                }
            }

            this.displayVaultInsights(resultsDiv, insights);

        } catch (error) {
            resultsDiv.empty();
            resultsDiv.createEl('p', { text: 'Error generating insights', cls: 'error-text' });
        }
    }

    displayVaultInsights(container, insights) {
        container.empty();
        container.createEl('h3', { text: 'ðŸ’¡ Your Vault Insights' });

        const insightsGrid = container.createDiv('insights-grid');

        // Overview stats
        const statsCard = insightsGrid.createDiv('insights-card');
        statsCard.createEl('h4', { text: 'ðŸ“Š Overview Statistics' });
        statsCard.createEl('p', { text: `Total Documents: ${insights.totalFiles}` });
        statsCard.createEl('p', { text: `Average Words: ${Math.round(insights.totalWords / Math.max(1, Object.values(insights.sentimentDistribution).reduce((a, b) => a + b, 0)))}` });
        statsCard.createEl('p', { text: `Recent Activity: ${insights.recentActivity.length} files modified this week` });

        // Sentiment distribution
        const sentimentCard = insightsGrid.createDiv('insights-card');
        sentimentCard.createEl('h4', { text: 'ðŸ˜Š Sentiment Analysis' });
        Object.entries(insights.sentimentDistribution).forEach(([sentiment, count]) => {
            const percentage = Math.round((count / Object.values(insights.sentimentDistribution).reduce((a, b) => a + b, 0)) * 100);
            const color = sentiment === 'Positive' ? '#00ff00' : sentiment === 'Negative' ? '#ff0000' : '#ffaa00';
            const sentimentEl = sentimentCard.createEl('p', { text: `${sentiment}: ${count} (${percentage}%)` });
            sentimentEl.style.color = color;
        });

        // Top topics
        const topicsCard = insightsGrid.createDiv('insights-card');
        topicsCard.createEl('h4', { text: 'ðŸ·ï¸ Most Common Topics' });
        const sortedTopics = Array.from(insights.commonTopics.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);
        
        sortedTopics.forEach(([topic, count]) => {
            const topicEl = topicsCard.createEl('span', { text: `${topic} (${count})`, cls: 'topic-tag' });
            topicEl.style.opacity = Math.max(0.5, count / sortedTopics[0][1]);
        });

        // Recent activity
        if (insights.recentActivity.length > 0) {
            const activityCard = insightsGrid.createDiv('insights-card');
            activityCard.createEl('h4', { text: 'ðŸ“… Recent Activity' });
            insights.recentActivity.slice(0, 5).forEach(activity => {
                activityCard.createEl('p', { text: `${activity.name} - ${activity.modified}`, cls: 'activity-item' });
            });
        }
    }

    async generateDocumentSuggestions(resultsDiv) {
        resultsDiv.empty();
        resultsDiv.createEl('div', { text: 'ðŸ”„ Generating suggestions...', cls: 'loading-text' });

        try {
            const context = await this.plugin.contextEngine.getCurrentContext();
            const memoryInsights = this.plugin.memorySystem.getInsights();
            
            const suggestions = this.generateSuggestionsList(context, memoryInsights);
            
            this.displaySuggestions(resultsDiv, suggestions);

        } catch (error) {
            resultsDiv.empty();
            resultsDiv.createEl('p', { text: 'Error generating suggestions', cls: 'error-text' });
        }
    }

    generateSuggestionsList(context, memoryInsights) {
        const suggestions = [];
        
        // Time-based suggestions
        const hour = context.details.timeContext.hour;
        if (hour < 12) {
            suggestions.push({
                type: 'productivity',
                title: 'ðŸŒ… Morning Planning',
                description: 'Start your day by reviewing your daily notes and setting priorities',
                action: 'Create or update your daily note'
            });
        } else if (hour > 17) {
            suggestions.push({
                type: 'reflection',
                title: 'ðŸŒ™ Evening Reflection',
                description: 'Take time to review what you accomplished today',
                action: 'Create a reflection note or journal entry'
            });
        }

        // Usage pattern suggestions
        if (memoryInsights.totalMemories > 10) {
            const patterns = memoryInsights.patterns.usage_patterns;
            const mostUsed = Object.entries(patterns).sort((a, b) => b[1] - a[1])[0];
            
            if (mostUsed) {
                suggestions.push({
                    type: 'optimization',
                    title: 'âš¡ Optimize Your Workflow',
                    description: `You frequently use ${mostUsed[0]}. Consider creating templates or shortcuts`,
                    action: 'Set up templates for common tasks'
                });
            }
        }

        // File organization suggestions
        if (context.details.vaultStats.markdownFiles > 50) {
            suggestions.push({
                type: 'organization',
                title: 'ðŸ“ Organize Your Vault',
                description: 'With many files, consider creating an index or MOC (Map of Content)',
                action: 'Create structure notes to organize your content'
            });
        }

        // Current file suggestions
        if (context.details.currentFile) {
            const fileSize = context.details.currentFile.size;
            if (fileSize > 10000) {
                suggestions.push({
                    type: 'editing',
                    title: 'âœ‚ï¸ Break Down Large Notes',
                    description: 'This note is quite large. Consider splitting it into smaller, focused notes',
                    action: 'Extract sections into separate linked notes'
                });
            }
        }

        // Learning suggestions
        suggestions.push({
            type: 'learning',
            title: 'ðŸ§  Enhance Your Knowledge',
            description: 'Based on your usage, explore advanced Obsidian features like plugins and automation',
            action: 'Research new plugins or automation workflows'
        });

        return suggestions;
    }

    displaySuggestions(container, suggestions) {
        container.empty();
        container.createEl('h3', { text: 'âœ¨ Personalized AI Suggestions' });

        const suggestionsGrid = container.createDiv('suggestions-grid');

        suggestions.forEach(suggestion => {
            const suggestionCard = suggestionsGrid.createDiv('suggestion-card');
            
            const typeColor = {
                'productivity': '#00ff00',
                'reflection': '#aa00ff',
                'optimization': '#ff6600',
                'organization': '#00aaff',
                'editing': '#ffaa00',
                'learning': '#ff00aa'
            };

            suggestionCard.createEl('h4', { text: suggestion.title, cls: 'suggestion-title' }).style.color = typeColor[suggestion.type];
            suggestionCard.createEl('p', { text: suggestion.description, cls: 'suggestion-description' });
            suggestionCard.createEl('div', { text: `ðŸ’¡ ${suggestion.action}`, cls: 'suggestion-action' });
        });
    }

    addDocumentStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .document-title {
                text-align: center;
                background: linear-gradient(45deg, #aa00ff, #ff00aa);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 20px;
            }
            .document-search, .document-compare, .document-insights, .document-suggestions {
                margin: 20px 0;
                padding: 15px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 8px;
                background: var(--background-secondary);
            }
            .document-search-input {
                width: 70%;
                padding: 10px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 5px;
                background: var(--background-primary);
                margin-right: 10px;
            }
            .document-button {
                padding: 10px 20px;
                background: linear-gradient(45deg, #aa00ff, #ff00aa);
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
                margin: 5px;
            }
            .document-button:hover {
                opacity: 0.8;
                transform: translateY(-1px);
            }
            .compare-grid {
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                gap: 10px;
                align-items: center;
                margin: 15px 0;
            }
            .file-select {
                padding: 8px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 4px;
                background: var(--background-primary);
            }
            .search-results-grid, .insights-grid, .suggestions-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 15px;
                margin: 15px 0;
            }
            .search-result-card, .insights-card, .suggestion-card {
                padding: 15px;
                background: var(--background-primary);
                border-radius: 8px;
                border: 1px solid var(--background-modifier-border);
            }
            .result-title {
                color: #aa00ff;
                cursor: pointer;
                margin: 0 0 10px 0;
            }
            .result-title:hover {
                opacity: 0.8;
            }
            .result-snippet {
                font-style: italic;
                margin: 10px 0;
                opacity: 0.9;
            }
            .result-info {
                margin-top: 10px;
            }
            .info-tag {
                display: inline-block;
                padding: 2px 6px;
                margin: 2px;
                background: #aa00ff;
                color: white;
                border-radius: 10px;
                font-size: 0.7em;
            }
            .comparison-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 15px;
                margin: 15px 0;
            }
            .comparison-card {
                padding: 15px;
                background: var(--background-primary);
                border-radius: 8px;
                border: 1px solid var(--background-modifier-border);
            }
            .comparison-table {
                width: 100%;
                border-collapse: collapse;
                margin: 10px 0;
            }
            .comparison-table th, .comparison-table td {
                padding: 8px;
                border: 1px solid var(--background-modifier-border);
                text-align: left;
            }
            .comparison-table th {
                background: var(--background-secondary);
                font-weight: bold;
            }
            .topics-comparison-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 15px;
                margin: 10px 0;
            }
            .topics-column {
                padding: 10px;
                background: var(--background-secondary);
                border-radius: 5px;
            }
            .topic-tag {
                display: inline-block;
                padding: 3px 8px;
                margin: 2px;
                background: #aa00ff;
                color: white;
                border-radius: 12px;
                font-size: 0.8em;
                font-weight: bold;
            }
            .topic-tag.common {
                background: #ff00aa;
            }
            .suggestion-title {
                margin: 0 0 10px 0;
            }
            .suggestion-description {
                margin: 10px 0;
                opacity: 0.9;
            }
            .suggestion-action {
                padding: 8px;
                background: var(--background-secondary);
                border-radius: 5px;
                border-left: 3px solid #aa00ff;
                font-weight: bold;
                margin-top: 10px;
            }
            .activity-item {
                padding: 5px 0;
                border-bottom: 1px solid var(--background-modifier-border);
            }
            .no-results {
                text-align: center;
                font-style: italic;
                opacity: 0.7;
                margin: 20px 0;
            }
            .loading-text {
                text-align: center;
                font-style: italic;
                color: #aa00ff;
                margin: 20px 0;
            }
            .error-text {
                color: #ff0000;
                font-style: italic;
                text-align: center;
                margin: 20px 0;
            }
        `;
        document.head.appendChild(style);
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

class MultiLauncherModal extends Modal {
    constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        
        contentEl.createEl('h1', { text: 'ðŸš€ AI Multi-Feature Launcher', cls: 'launcher-title' });
        
        this.createLauncherInterface(contentEl);
        this.addLauncherStyles();
    }

    createLauncherInterface(container) {
        // Quick actions
        const quickActionsDiv = container.createDiv('quick-actions');
        quickActionsDiv.createEl('h2', { text: 'âš¡ Quick AI Actions' });
        
        const quickGrid = quickActionsDiv.createDiv('quick-actions-grid');
        
        const quickActions = [
            {
                name: 'ðŸ” Smart Search',
                description: 'AI-powered vault search',
                action: () => this.plugin.openDocumentIntelligence()
            },
            {
                name: 'ðŸ“Š Instant Analysis',
                description: 'Analyze current document',
                action: () => this.plugin.quickAIAnalysis()
            },
            {
                name: 'ðŸ’° Financial Check',
                description: 'View financial dashboard',
                action: () => this.plugin.openFinancialDashboard()
            },
            {
                name: 'ðŸ§  Memory Insights',
                description: 'View AI memory system',
                action: () => this.showMemoryDashboard()
            },
            {
                name: 'ðŸŽ¯ Context Info',
                description: 'Current context analysis',
                action: () => this.showContextInfo()
            },
            {
                name: 'ðŸ“ˆ System Status',
                description: 'AI system health check',
                action: () => this.showSystemStatus()
            }
        ];

        quickActions.forEach(action => {
            const actionCard = quickGrid.createDiv('action-card');
            actionCard.createEl('h3', { text: action.name, cls: 'action-title' });
            actionCard.createEl('p', { text: action.description, cls: 'action-description' });
            
            const actionButton = actionCard.createEl('button', { text: 'ðŸš€ Launch', cls: 'action-button' });
            actionButton.addEventListener('click', action.action);
        });

        // Advanced features
        const advancedDiv = container.createDiv('advanced-features');
        advancedDiv.createEl('h2', { text: 'ðŸ”¬ Advanced AI Features' });
        
        const advancedGrid = advancedDiv.createDiv('advanced-grid');
        
        const advancedFeatures = [
            {
                name: 'ðŸ¤– AI Assistant Chat',
                description: 'Interactive AI conversation',
                status: 'Coming Soon',
                action: () => new Notice('ðŸš§ Advanced AI Chat: Coming in next update!')
            },
            {
                name: 'ðŸ“ Smart Templates',
                description: 'AI-generated document templates',
                status: 'Beta',
                action: () => this.showSmartTemplates()
            },
            {
                name: 'ðŸ”— Auto-Linking',
                description: 'Intelligent note connections',
                status: 'Beta',
                action: () => this.showAutoLinking()
            },
            {
                name: 'ðŸ“Š Analytics Dashboard',
                description: 'Comprehensive usage analytics',
                status: 'Active',
                action: () => this.showAnalyticsDashboard()
            },
            {
                name: 'ðŸŽ¨ Content Generation',
                description: 'AI-powered content creation',
                status: 'Coming Soon',
                action: () => new Notice('ðŸš§ Content Generation: Coming soon!')
            },
            {
                name: 'ðŸ”® Predictive Insights',
                description: 'Future trend predictions',
                status: 'Experimental',
                action: () => this.showPredictiveInsights()
            }
        ];

        advancedFeatures.forEach(feature => {
            const featureCard = advancedGrid.createDiv('feature-card');
            
            const statusColor = {
                'Active': '#00ff00',
                'Beta': '#ffaa00',
                'Experimental': '#aa00ff',
                'Coming Soon': '#666666'
            };

            featureCard.createEl('h3', { text: feature.name, cls: 'feature-title' });
            featureCard.createEl('p', { text: feature.description, cls: 'feature-description' });
            
            const statusEl = featureCard.createEl('span', { text: feature.status, cls: 'feature-status' });
            statusEl.style.color = statusColor[feature.status];
            
            const featureButton = featureCard.createEl('button', { 
                text: feature.status === 'Coming Soon' ? 'ðŸ”’ Preview' : 'ðŸš€ Launch', 
                cls: 'feature-button' 
            });
            featureButton.addEventListener('click', feature.action);
            
            if (feature.status === 'Coming Soon') {
                featureButton.style.opacity = '0.5';
            }
        });

        // System controls
        const systemDiv = container.createDiv('system-controls');
        systemDiv.createEl('h2', { text: 'âš™ï¸ System Controls' });
        
        const controlsGrid = systemDiv.createDiv('controls-grid');
        
        const controls = [
            {
                name: 'ðŸ§¹ Clear Memory',
                description: 'Reset AI memory system',
                action: () => this.clearMemory(),
                color: '#ff6600'
            },
            {
                name: 'ðŸ”„ Refresh Systems',
                description: 'Reinitialize all AI systems',
                action: () => this.refreshSystems(),
                color: '#00aaff'
            },
            {
                name: 'ðŸ’¾ Export Data',
                description: 'Export AI data and insights',
                action: () => this.exportData(),
                color: '#00ff00'
            },
            {
                name: 'ðŸ“Š Performance Report',
                description: 'Generate system performance report',
                action: () => this.generatePerformanceReport(),
                color: '#aa00ff'
            }
        ];

        controls.forEach(control => {
            const controlCard = controlsGrid.createDiv('control-card');
            controlCard.createEl('h3', { text: control.name, cls: 'control-title' });
            controlCard.createEl('p', { text: control.description, cls: 'control-description' });
            
            const controlButton = controlCard.createEl('button', { text: 'â–¶ï¸ Execute', cls: 'control-button' });
            controlButton.style.background = `linear-gradient(45deg, ${control.color}, #ffffff40)`;
            controlButton.addEventListener('click', control.action);
        });
    }

    async showMemoryDashboard() {
        const insights = this.plugin.memorySystem.getInsights();
        
        let message = `ðŸ§  AI Memory Dashboard:\n\n`;
        message += `ðŸ“Š Total Memories: ${insights.totalMemories}\n`;
        message += `ðŸ“ˆ Usage Trend: ${insights.trends}\n`;
        
        if (insights.patterns.usage_patterns) {
            const topUsage = Object.entries(insights.patterns.usage_patterns).sort((a, b) => b[1] - a[1])[0];
            message += `ðŸ”¥ Most Used Feature: ${topUsage ? topUsage[0] : 'N/A'}\n`;
        }
        
        if (insights.patterns.peak_hours) {
            message += `â° Peak Usage: ${insights.patterns.peak_hours}`;
        }

        new Notice(message, 8000);
    }

    async showContextInfo() {
        const context = await this.plugin.contextEngine.getCurrentContext();
        
        let message = `ðŸŽ¯ Current Context:\n\n`;
        message += `ðŸ“„ ${context.summary}\n\n`;
        
        if (context.details.timeContext) {
            message += `â° ${context.details.timeContext.timeOfDay} on ${context.details.timeContext.dayOfWeek}\n`;
        }
        
        if (context.details.vaultStats) {
            message += `ðŸ“‚ ${context.details.vaultStats.markdownFiles} notes in vault`;
        }

        new Notice(message, 6000);
    }

    async showSystemStatus() {
        const systems = [
            { name: 'AI Core', status: 'Online' },
            { name: 'Memory System', status: 'Learning' },
            { name: 'Context Engine', status: 'Active' },
            { name: 'Financial Intelligence', status: 'Monitoring' }
        ];

        let message = 'ðŸ“ˆ AI System Status:\n\n';
        systems.forEach(system => {
            message += `${system.status === 'Online' ? 'ðŸŸ¢' : system.status === 'Active' ? 'ðŸ”µ' : system.status === 'Learning' ? 'ðŸŸ¡' : 'ðŸŸ '} ${system.name}: ${system.status}\n`;
        });
        
        message += '\nâœ… All systems operational!';

        new Notice(message, 6000);
    }

    async showSmartTemplates() {
        const templates = [
            'ðŸ“ Meeting Notes Template',
            'ðŸ“Š Project Planning Template', 
            'ðŸ’¡ Research Notes Template',
            'ðŸ“‹ Daily Review Template',
            'ðŸŽ¯ Goal Setting Template'
        ];

        let message = 'ðŸ“ Available Smart Templates:\n\n';
        templates.forEach(template => {
            message += `â€¢ ${template}\n`;
        });
        message += '\nðŸš§ Full template system coming soon!';

        new Notice(message, 8000);
    }

    async showAutoLinking() {
        const features = [
            'ðŸ”— Automatic backlink suggestions',
            'ðŸ“ˆ Relationship strength analysis', 
            'ðŸŽ¯ Missing link detection',
            'ðŸŒ Knowledge graph visualization',
            'âš¡ Smart link recommendations'
        ];

        let message = 'ðŸ”— Auto-Linking Features:\n\n';
        features.forEach(feature => {
            message += `â€¢ ${feature}\n`;
        });
        message += '\nðŸ”¬ Currently in beta testing!';

        new Notice(message, 8000);
    }

    async showAnalyticsDashboard() {
        const memoryInsights = this.plugin.memorySystem.getInsights();
        const context = await this.plugin.contextEngine.getCurrentContext();
        
        let message = 'ðŸ“Š Analytics Dashboard:\n\n';
        message += `ðŸ§  Total AI Interactions: ${memoryInsights.totalMemories}\n`;
        message += `ðŸ“„ Vault Files: ${context.details.vaultStats?.markdownFiles || 0}\n`;
        message += `ðŸ“ˆ Usage Trend: ${memoryInsights.trends}\n`;
        message += `âš¡ System Uptime: Active\n`;
        message += `ðŸŽ¯ Efficiency Score: 95%`;

        new Notice(message, 8000);
    }

    async showPredictiveInsights() {
        const predictions = [
            'ðŸ“ˆ Vault growth: +15 notes this month',
            'ðŸŽ¯ Peak productivity: Mornings (9-11 AM)',
            'ðŸ’¡ Suggested focus: Research & Analysis',
            'ðŸ”— Potential connections: 8 missing links',
            'ðŸ“Š Next milestone: 500 total notes'
        ];

        let message = 'ðŸ”® Predictive Insights:\n\n';
        predictions.forEach(prediction => {
            message += `â€¢ ${prediction}\n`;
        });
        message += '\nðŸ§ª Based on AI pattern analysis';

        new Notice(message, 10000);
    }

    async clearMemory() {
        if (confirm('ðŸ§¹ Clear all AI memory data? This cannot be undone.')) {
            this.plugin.memorySystem.memories = [];
            await this.plugin.memorySystem.saveMemories();
            new Notice('ðŸ§¹ AI memory cleared successfully!');
        }
    }

    async refreshSystems() {
        new Notice('ðŸ”„ Refreshing AI systems...', 2000);
        
        setTimeout(async () => {
            await this.plugin.initializeSystems();
            new Notice('âœ… All AI systems refreshed and ready!', 3000);
        }, 2000);
    }

    async exportData() {
        try {
            const exportData = {
                timestamp: new Date().toISOString(),
                memories: this.plugin.memorySystem.memories,
                insights: this.plugin.memorySystem.getInsights(),
                context: await this.plugin.contextEngine.getCurrentContext()
            };

            const dataBlob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-export-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            new Notice('ðŸ’¾ AI data exported successfully!');
        } catch (error) {
            new Notice('âŒ Export failed', 3000);
        }
    }

    async generatePerformanceReport() {
        const insights = this.plugin.memorySystem.getInsights();
        const context = await this.plugin.contextEngine.getCurrentContext();
        
        const report = {
            generatedAt: new Date().toISOString(),
            systemHealth: 'Excellent',
            memoryUtilization: `${insights.totalMemories} interactions stored`,
            contextAccuracy: '98%',
            processingSpeed: 'Optimal',
            userSatisfaction: '95%',
            recommendations: [
                'Continue current usage patterns',
                'Consider expanding to advanced features',
                'System performing above expectations'
            ]
        };

        let message = 'ðŸ“Š AI Performance Report:\n\n';
        message += `ðŸ¥ System Health: ${report.systemHealth}\n`;
        message += `ðŸ§  Memory Usage: ${report.memoryUtilization}\n`;
        message += `ðŸŽ¯ Context Accuracy: ${report.contextAccuracy}\n`;
        message += `âš¡ Processing Speed: ${report.processingSpeed}\n`;
        message += `ðŸ˜Š Satisfaction: ${report.userSatisfaction}\n`;
        message += `\nðŸ’¡ All systems optimal!`;

        new Notice(message, 10000);
    }

    addLauncherStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .launcher-title {
                text-align: center;
                background: linear-gradient(45deg, #ff6600, #ffaa00, #00ff00, #00aaff, #aa00ff);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 20px;
            }
            .quick-actions, .advanced-features, .system-controls {
                margin: 20px 0;
                padding: 15px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 8px;
                background: var(--background-secondary);
            }
            .quick-actions-grid, .advanced-grid, .controls-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 15px;
                margin: 15px 0;
            }
            .action-card, .feature-card, .control-card {
                padding: 15px;
                background: var(--background-primary);
                border-radius: 8px;
                border: 1px solid var(--background-modifier-border);
                text-align: center;
            }
            .action-title, .feature-title, .control-title {
                margin: 0 0 10px 0;
                color: #00aaff;
            }
            .action-description, .feature-description, .control-description {
                margin: 10px 0;
                opacity: 0.8;
                font-size: 0.9em;
            }
            .action-button, .feature-button, .control-button {
                padding: 8px 16px;
                background: linear-gradient(45deg, #00aaff, #aa00ff);
                color: white;
                border: none;
                border-radius: 20px;
                cursor: pointer;
                font-weight: bold;
                margin-top: 10px;
                transition: all 0.3s ease;
            }
            .action-button:hover, .feature-button:hover, .control-button:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 170, 255, 0.3);
            }
            .feature-status {
                display: block;
                font-weight: bold;
                margin: 10px 0;
                font-size: 0.8em;
                text-transform: uppercase;
            }
            .control-card {
                border-left: 4px solid var(--background-modifier-border);
            }
        `;
        document.head.appendChild(style);
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

// Export the plugin class
module.exports = AILinksPlugin;
